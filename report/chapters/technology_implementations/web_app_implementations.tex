\chapter{Web Application Implementations}
This section will contain information and reasoning about our use of two of Microsofts
web application technologies: ASP.NET MVC, and ASP.NET Web API.

Our use of these technologies stems from requirements by the customer, who already uses Microsoft technology, and required that this project also made use of MS technology in order to fit into their systems. In particular this was to ease interaction with Entity Framework, which was another requirement for technology to be used in database communication. 
\newpage

\section{Microsoft ASP.NET MVC}

ASP.NET MVC was used for easy, fast testing, and enabled easy visualization data flow, and event sequences during the testing process. We also used it to ease into the technology
we needed to use, seeing as it was more familiar to us. One group member already had previous experience with ASP.NET MVC, which enabled us to easily set up the project and get started
without any trial-and-error in the setup. This enabled more focus on database setup and interaction, as well as the business logic of the project.

There are three other reasons other than internal and product specific reasons that made an ASP.NET MVC test product worth the time spent on it. The first reason being to more efficiently communicate functions and progress to the customer, who also obviously benefited from our ability to visualizefunctions and sequences as we progressed. We believe that this helped a great deal in ensuring efficient and fast communication, and to prevent misunderstandings. The second reason was that it doubles as an effective demonstration tool at the end presentation of the project, where we would
have had to create some form of visual presentation aid for the product anyhow, in order to demonstrate the product as actually functioning. The third and final of these reasons was that it might give
added value to the customer in the form of a visual guide and overview for future API users of the overall structure of the product. At least the customer agreed with us when we presented this idea. They can potentially use it as a guide on how to use the Web API functions in a full product, at least in the minimally required sense.


\section{Microsoft ASP.NET Web API}
\label{subsec:webapiimpl}

ASP.NET Web API was the main outward technology interface of our product, as specified by the customers initial specifications. None of the team had any previous experience
with this technology, so we postponed the implementation until late in the development cycle, when everything else was implemented. In doing so we hoped to remove any other points
of failure during this implementation.

Web API turned out to be a bit lacking in modularity, so it limited our ability to implement the non-functional requirement of modifiability. There were few meaningful ways to implement
polymorphism and interfaces in the code; most possibilities were redundant or trivial when knowledge of Web APIs design and purpose is taken into account. That is to say that any meaningful
modifications will have to be done to Web API itself, and not to the product. The product does fullfill criteria for modifiability as such, when the use of Web API is taken into account;
however that was not a consequence of any design or effort on our part, merely a by-product of following the functional requirement of Web API implementation and use.

Our implementation mostly follows the specifications for Web API, except for one method which does not follow best practice due to issues with Web APIs automatic argument parsing and model binding.
As a result, that method implementation and the function it fulfills is slightly fragile, and harder to maintain. It was however neccessary in order to achieve the desired function at all, and still
keep the much more important attribute of outward simplicity and ease of testing. Any other solution would most likely have sacrificed the atomicity of the function, which would have complicated testing a great deal, and introduced new sources for bugs. Further discussion on that can be found in the issues section \ref{subsubsec:webapiissues} on page \pageref{subsubsec:webapiissues}.
